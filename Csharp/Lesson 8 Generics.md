# Тема урока: Generics

- Что такое Generics ?
- Разница между обобщениями в C# и шаблонами в C++.
- Как использовать Generics в C# ?
- ключевое слово "where" в Generics и использование ограничений.

## Что такое Generics ?

Generics (обобщения) в C# позволяют создавать классы, интерфейсы и методы, которые могут работать с любым типом данных. Это позволяет писать более гибкий и переиспользуемый код, избегая дублирования кода для разных типов.

Также он решает проблему с `boxing` и `unboxing`, в тех типах где раньше мы использовали `object` для хранения значений, теперь мы можем использовать обобщения, которые позволяют работать с конкретными типами без необходимости преобразования типов.

## Разница между обобщениями в C# и шаблонами в C++

В C# обобщения реализованы на уровне языка и компилятора, что позволяет создавать более безопасный и оптимизированный код. В C++ шаблоны реализованы на уровне препроцессора, что может приводить к большему количеству ошибок времени компиляции и увеличению размера исполняемого файла. По факту в C++ шаблоны это сахар, который мы используем для упрощения работы с типами, а в C# это полноценная часть языка.

К примеру такой код в C++:

```cpp
template <typename T>
void print(T value) {
    std::cout << value << std::endl;
}
```

если вы сделаете такой вызов

```cpp
print(5);
print("Hello");
```

то в C++ будет создано две функции, одна для `int`, другая для `const char*`.
А в C# такой код будет выглядеть так:

```csharp
void Print<T>(T value) {
    Console.WriteLine(value);
}
```

И при вызове `Print(5)` и `Print("Hello")` будет создана одна функция, которая будет работать с любым типом данных на уровне компиляции. В IL тоже будет создана одна функция, которая будет работать с любым типом данных, но при вызове будет использоваться конкретный тип данных.

## Как использовать Generics в C# ?

Синтаксис очень простой, мы не пишем никаких дополнительных ключевых слов, просто указываем тип в угловых скобках.

Пример использования обобщений в C#:

```csharp
public class GenericClass<T>
{
    private T _value;

    public GenericClass(T value)
    {
        _value = value;
    }

    public T GetValue()
    {
        return _value;
    }
}
```

Можно также использовать обобщения в методах:

```csharp
void PrintValue<T>(T value)
{
    Console.WriteLine(value);
}
```

Вы также можете передавать несколько типов в обобщения:

```csharp
public class Pair<T1, T2>
{
    private T1 _first;
    private T2 _second;

    public Pair(T1 first, T2 second)
    {
        _first = first;
        _second = second;
    }

    public T1 First => _first;
    public T2 Second => _second;
}
```

Есть ключевые слова `in`, `out` которые позволяют использовать обобщения в качестве параметров и возвращаемых значений. Данные слова мы используем в обобщении делегатов и интерфейсов, чтобы указать, что тип может быть только входным или выходным.

```csharp
public interface IProcessor<in T>
{
    void Process(T item);
}
public interface IResult<out T>
{
    T GetResult();
}
```

или же в делегатах:

```csharp
public delegate void Processor<in T>(T item);
public delegate T Result<out T>();
```

**In** - это контравариантность, что означает, что тип может быть только входным параметром.
**Out** - это ковариантность, что означает, что тип может быть только выходным параметром.

## Ключевое слово "where" в Generics и использование ограничений

Ключевое слово `where` позволяет задавать ограничения на типы, которые могут быть использованы в обобщениях. Это позволяет гарантировать, что типы, передаваемые в обобщения, будут иметь определенные свойства или методы.

Причем ограничения могут быть разными:

- **Ограничение на тип или базовый тип**
- **Ограничение на конструктор**

В первом случае мы можем указать, что тип должен быть производным от определенного класса или реализовывать определенный интерфейс:

```csharp
public class Repository<T> where T : Entity
{
    public void Add(T entity)
    {
        // Добавление сущности в репозиторий
    }
}
```

или как я писал на прошлом уроке с примером где писал MiddleWareBuilder:

```csharp
public class MiddlewareBuilder<T> where T : IMiddleware
{
    private readonly Stack<Type> _middlewares = new();

    public MiddlewareBuilder<T> Use<T>()
    {
        _middlewares.Push(typeof(T));
        return this;
    }
    public void Build()
    {
        // Логика сборки middleware
    }
}
```

Во втором случае мы можем указать, что тип должен иметь конструктор без параметров:

```csharp
public class Factory<T> where T : new()
{
    public T Create()
    {
        return new T(); // Создание экземпляра типа T
    }
}
```

Также можно комбинировать ограничения:

```csharp
public class Service<T> where T : class, new()
{
    private readonly T _instance;

    public Service()
    {
        _instance = new T(); // Создание экземпляра типа T
    }

    public void DoSomething()
    {
        // Логика работы с экземпляром T
    }
}
```

Например в этом примере `T` должен быть ссылочным типом и иметь конструктор без параметров.

Можно также написать туда struct:

```csharp
public class ValueService<T> where T : struct
{
    private readonly T _value;

    public ValueService(T value)
    {
        _value = value; // Значение типа T
    }

    public T GetValue()
    {
        return _value;
    }
}
```

Также можно использовать несколько ограничений одновременно:

```csharp
public class GenericService<T> where T : class, IDisposable, new()
{
    private readonly T _instance;

    public GenericService()
    {
        _instance = new T(); // Создание экземпляра типа T
    }

    public void Dispose()
    {
        _instance.Dispose(); // Вызов метода Dispose
    }
}
```

Таким образом, обобщения в C# позволяют создавать гибкие и переиспользуемые компоненты, которые могут работать с различными типами данных, обеспечивая при этом безопасность типов и оптимизацию производительности. Использование ключевого слова `where` позволяет задавать ограничения на типы, что делает код более предсказуемым и безопасным.