# Тема урока:

- Деконструкторы
- Исключения
- checked и unchecked
- using
- enum


# Деконструкторы

Деконструктор в C# - это специальный метод, который вызывается при уничтожении объекта класса. Он используется для освобождения ресурсов, которые были выделены объекту во время его жизни. Деконструктор имеет то же имя, что и класс, но с символом тильда (~) перед ним. Не путайте деконструктор с деструктором в других языках программирования, таких как C++. В C# деконструкторы не принимают параметров и не могут быть вызваны явно(Могли вызываться в .NET Framework). Они вызываются автоматически при сборке мусора (garbage collection). Деконструкторы могут быть полезны, когда необходимо освободить неуправляемые ресурсы, такие как файловые дескрипторы или соединения с базой данных.

```csharp
class MyClass
{
    public MyClass()
    {
        Console.WriteLine("Конструктор вызван");
    }

    ~MyClass()
    {
        Console.WriteLine("Деконструктор вызван");
    }
}
```

# Исключения

Исключения в C# - это механизм обработки ошибок, который позволяет программе реагировать на ошибки и исключительные ситуации во время выполнения. Исключения могут возникать по различным причинам, таким как деление на ноль, доступ к несуществующему элементу массива или ошибка ввода-вывода. В C# для обработки исключений используется блок try-catch-finally.

**ЗАПОМНИТЕ**

Есть золотое правило: "Если вы можете обработать исключение использовав условие, то не используйте исключение". Исключения - это дорогостоящая операция, и их использование должно быть оправдано. Если вы можете избежать исключения с помощью проверки условий, то лучше использовать это условие. Исключения должны использоваться только для обработки ошибок, которые не могут быть предсказаны заранее.

Для того чтобы пробросить исключение, необходимо использовать оператор `throw`. Он позволяет создать новое исключение или повторно выбросить существующее. Например:

```csharp
try
{
    // Код, который может вызвать исключение
}
catch (Exception ex)
{
    // Обработка исключения
    throw new Exception("Произошла ошибка", ex);
}
```

Здесь нельзя пробрасывать просто литералы как вы это делали в С++. Можно пробросить только объект класса Exception или его наследников. Также можно использовать `throw;` для повторного выброса текущего исключения без изменения его состояния. Например:

```csharp
try
{
    // Код, который может вызвать исключение
}
catch (Exception ex)
{
    // Обработка исключения
    throw; // Повторный выброс текущего исключения
}
```

В примере выше `throw;` используется для повторного выброса текущего исключения без создания нового объекта исключения. Это позволяет сохранить стек вызовов и информацию о месте возникновения исключения. Однако, если вы хотите создать новое исключение, то используйте `throw new Exception("Сообщение", ex);`, где `ex` - это текущее исключение, что я настоятельно не рекомендую делать. Стэк вызовов - это очень важная информация.

Также вам нужно знать что необязательно писать `throw` в catch блоке. Вы можете просто обработать исключение и продолжить выполнение программы. Например:

```csharp
void foo(int num)
{
    if (num < 0)
    {
        throw new ArgumentException("Число не может быть отрицательным");
    }
}

```

Как видите в данном примере нам не нужно писать try-catch блок. А как будет выглядеть вызов этого метода ?

```csharp
try
{
    foo(-1);
}
catch (ArgumentException ex)
{
    Console.WriteLine(ex.Message);
}
```

В этом примере мы вызываем метод `foo` с отрицательным числом, что вызывает исключение `ArgumentException`. Мы обрабатываем это исключение в блоке `catch`, выводя сообщение об ошибке на консоль. Если бы мы не использовали блок `try-catch`, программа бы завершилась с ошибкой.

Можно было написать и так:

```csharp
try
{
    foo(-1);
}
catch (ArgumentException ex)
{
    Console.WriteLine(ex.Message);
    throw; // Повторный выброс текущего исключения
}
```

А сейчас получилось что мы вывели информацию об ошибке и пробросили исключение еще дальше. Так нужно делать в случае если мы делаем проверку в каком то методе, который вызывается другим объектом. Соответсветственно если мы не пробросим исключение, то другой объект не сможет обработать его. `Console.WriteLine(ex.Message);` я написал просто так, этого можно было и не делать, учитывая что мы пробрасываем исключение дальше.

Допусти у меня такой вызов:

```csharp

var nums = new List<int> { 1, 2, 3, 4, 5 };

try
{
    DivideTo(nums, 0);
}
catch (DivideByZeroException ex)
{
    Console.WriteLine(ex.Message);
}



void DivideTo(List<int> nums, int divider)
{
   foreach (var num in nums)
   {
       try
       {
           Console.WriteLine(divider(num, divider));
       }
       catch (DivideByZeroException ex)
       {
           Console.WriteLine(ex.Message);
           throw; // Повторный выброс текущего исключения
       }
   }
}

float divider(int num, int divider)
{
    if (divider == 0)
    {
        throw new DivideByZeroException("На ноль делить нельзя");
    }
    return num / divider;
}

```


Для вас новым ключевым словом будет `finally`. Он используется для выполнения кода, который должен быть выполнен независимо от того, произошло исключение или нет. Блок `finally` всегда выполняется после блока `try` и `catch`, даже если в блоке `try` произошло исключение. Например:

```csharp
try
{
    FileStream fileStream = new FileStream("file.txt", FileMode.Open);
    // Тут вызываю метод который может вызвать исключение 
}
catch (Exception ex)
{
    // Обработка исключения
    Console.WriteLine(ex.Message);
}
finally
{
    // Код, который всегда выполняется
    fileStream.Close();
}

```

При этом блок `finally` можно использовать без блока `catch`. Например:

```csharp 
try
{
    FileStream fileStream = new FileStream("file.txt", FileMode.Open);
    // Тут вызываю метод который может вызвать исключение 
}
finally
{
    // Код, который всегда выполняется
    fileStream.Close();
}
```

В таком написании есть смысл, даже встроенные элементы в C# написаны таким образом. Например ключевое слово `using`, `lock`, `checked` и `unchecked`. Они используют блок `finally` для выполнения кода, который должен быть выполнен независимо от того, произошло исключение или нет. 

## ApplicationException vs Exception 

Для того чтобы создать собственное исключение, необходимо создать класс, который наследуется от класса `Exception` или его производных. Например:

```csharp 
class MyCustomException : Exception
{
    public int ErrorCode { get; init;}
    public MyCustomException(string message, int errorCode) : base(message)
    {
        ErrorCode = errorCode;
    }

}
```
В этом примере мы создали класс `MyCustomException`, который наследуется от класса `Exception`. Мы добавили свойство `ErrorCode`, которое может использоваться для передачи дополнительной информации об ошибке. Конструктор принимает сообщение об ошибке и код ошибки, который передается в базовый класс `Exception`. 

Есть еще и класс `ApplicationException`, который является производным от класса `Exception`. Он предназначен для создания пользовательских исключений, которые могут быть использованы в приложениях. Класс `ApplicationException` был создан для того, чтобы разработчики могли создавать свои собственные исключения, но на практике его использование не является обязательным.

## checked и unchecked
`checked` и `unchecked` - это ключевые слова в C#, которые используются для управления проверкой переполнения арифметических операций. Они позволяют вам явно указать, хотите ли вы, чтобы компилятор проверял переполнение или нет.
Когда вы используете `checked`, компилятор будет проверять переполнение арифметических операций и выбрасывать исключение `OverflowException`, если оно произойдет. Например:

```csharp
int a = int.MaxValue;
int b = 1;
int c = checked(a + b); // Вызывает исключение OverflowException
```
В этом примере мы пытаемся сложить два числа, и так как сумма превышает максимальное значение типа `int`, компилятор выбрасывает исключение `OverflowException`.
Когда вы используете `unchecked`, компилятор не будет проверять переполнение арифметических операций, и результат будет обрезан до допустимого диапазона. Например:

```csharp
int a = int.MaxValue;
int b = 1;
int c = unchecked(a + b); // Результат будет равен int.MinValue
```

Можно сам проект по умолчанию настроить на использование `checked` или `unchecked`. Для этого нужно открыть файл проекта (.csproj) и добавить следующий код:

```xml
<PropertyGroup>
    <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
</PropertyGroup> 

```

# using

Директива `using` в C# используется сразу для нескольких целей: 
1. Импорт пространств имен
2. Определение области видимости для объектов, которые реализуют интерфейс `IDisposable`
3. Определение псевдонимов для пространств имен и типов


## Импорт пространств имен 
Директива `using` позволяет импортировать пространства имен, что упрощает доступ к классам и методам, определенным в этих пространствах имен. Например:

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
```

## Определение области видимости для объектов, которые реализуют интерфейс IDisposable 

В `C#` есть встроенный интерфейс `IDisposable`, который используется для освобождения ресурсов, занимаемых объектом. Даже если вы будете сами реализовывать класс, в котором вам нужно будет освободить ресурсы, то вам нужно будет реализовать интерфейс `IDisposable`. Как это работает ? 

К примеру мы хотим открыть файл, то нам нужно обязательно его закрыть. У класса FileStream по умолчанию есть метод Dispose, который закрывает файл. 

```csharp 
using (FileStream fileStream = new FileStream("file.txt", FileMode.Open))
{
    // Работа с файлом
} // fileStream.Dispose() вызывается автоматически 

```
или же новый синтаксис:

```csharp
using FileStream fileStream = new FileStream("file.txt", FileMode.Open);
```


```csharp

using MyClass a = new();

Console.WriteLine("End of program...");

class MyClass : IDisposable
{
    public void Dispose()
    {
       this.Close();
    }

    void Close()
    {
        Console.WriteLine("Closing resources...");   
    }
}
```

## Определение псевдонимов для пространств имен и типов

Директива `using` также позволяет создавать псевдонимы для пространств имен и типов, что может быть полезно для упрощения кода и избежания конфликтов имен. Например:

```csharp
using Project = MyCompany.MyProject;
using MyList = System.Collections.Generic.List<int>;
```

или же использоваить `using static` для статических классов:

```csharp
using static System.Console;
using static System.Math;

WriteLine(Sqrt(16));
```

# enum 

`enum` (перечисление) - это специальный тип данных в C#, который позволяет создавать набор именованных констант. Он используется для определения набора связанных значений, которые могут быть использованы в программе. Перечисления делают код более читаемым и понятным, так как вместо чисел или строк используются понятные имена.

```csharp
enum DaysOfWeek
{
    Sunday,
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday
}
```

В целом все точно так же как и в C++. 





